{"version":3,"file":"telegram-webapp-solid.umd.js","sources":["../node_modules/.pnpm/solid-js@1.4.2/node_modules/solid-js/dist/solid.js","../src/signals/haptic.ts","../src/signals/back-button.ts","../src/components/back-button.tsx","../src/signals/main-button.ts","../src/components/main-button.tsx","../node_modules/.pnpm/solid-js@1.4.2/node_modules/solid-js/web/dist/web.js","../src/components/stable-container.tsx","../src/components/haptic-button.tsx","../src/components/haptic-input.tsx","../src/signals/expand.ts","../src/signals/close.ts","../src/signals/data.ts","../src/signals/theme.ts","../src/signals/user.ts","../src/signals/viewport.ts","../src/components/libtest.tsx"],"sourcesContent":["let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  };\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(() => fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Updates = null;\n    if (!wait) Effects = null;\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    res = Transition.resolve;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = \"next\" in observer ? observer.next.bind(observer) : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n      };\n    },\n    [$$observable]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err = undefined;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count);\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  let e;\n  return createMemo(() => {\n    if ((e = errored()) != null) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(null))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = untrack(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered;\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","export function createHapticImpactSignal(\n  style: Parameters<\n    typeof window.Telegram.WebApp.HapticFeedback.impactOccurred\n  >[0]\n) {\n  return () => window.Telegram.WebApp.HapticFeedback.impactOccurred(style);\n}\n\nexport function createHapticSelectionSignal() {\n  return () => window.Telegram.WebApp.HapticFeedback.selectionChanged();\n}\n","import { createEffect, createSignal } from \"solid-js\";\nimport { createHapticImpactSignal } from \"./haptic\";\n\nexport type BackButtonProps = {\n  onClick?: () => void;\n  show?: boolean;\n  hapticForce?: Parameters<typeof createHapticImpactSignal>[0];\n};\n\nexport function createBackButtonSignal(props: BackButtonProps) {\n  const [visible, setVisible] = createSignal(window.Telegram.WebApp.BackButton.isVisible);\n  const hapticSignal = createHapticImpactSignal(props.hapticForce);\n\n  setVisible(props.show ?? visible());\n\n  createEffect(function updateVisibility() {\n    if (visible()) {\n      console.log('BackButtonSignal show')\n      window.Telegram.WebApp.BackButton.show();\n    } else {\n      console.log('BackButtonSignal hide');\n      window.Telegram.WebApp.BackButton.hide();\n    }\n  })\n\n  createEffect(function updateOnClick() {\n    if (props.onClick) {\n      window.Telegram.WebApp.BackButton.onClick(() => {\n        if (props.hapticForce && hapticSignal) {\n          hapticSignal();\n        }\n        props.onClick();\n      });\n    } else {\n      window.Telegram.WebApp.BackButton.onClick(undefined);\n    }\n  });\n\n  return {\n    visible,\n    setVisible,\n  }\n}\n","import { createEffect, onCleanup, onMount } from 'solid-js'\nimport { createBackButtonSignal } from '../signals/back-button'\nimport { createHapticImpactSignal } from '../signals/haptic'\n\nexport type BackButtonProps = {\n  onClick?: () => void\n  hapticForce?: Parameters<typeof createHapticImpactSignal>[0]\n}\n\nexport function BackButton(props: BackButtonProps) {\n  const backButton = createBackButtonSignal({\n    onClick: props.onClick,\n    hapticForce: props.hapticForce,\n    show: true,\n  })\n\n  onMount(() => {\n    backButton.setVisible(true)\n  })\n\n  onCleanup(() => {\n    backButton.setVisible(false)\n  })\n\n  return null\n}\n","import { createEffect, createSignal, onCleanup, onMount } from 'solid-js'\nimport { createHapticImpactSignal } from '../signals/haptic'\n\nexport type MainButtonProps = {\n  onClick?: () => void\n  text?: string | null\n  show?: boolean\n  hapticForce?: Parameters<typeof createHapticImpactSignal>[0]\n}\n\nexport function createMainButtonSignal(props: MainButtonProps) {\n  const originalText = window.Telegram.WebApp.MainButton.text;\n  const hapticSignal = createHapticImpactSignal(props.hapticForce);\n\n  const [visible, setVisible] = createSignal(window.Telegram.WebApp.MainButton.isVisible);\n  const [text, setText] = createSignal<string | null>(props.text ?? originalText);\n\n  setVisible(props.show ?? visible());\n\n  createEffect(function updateVisibility() {\n    if (visible()) {\n      console.log('MainButtonSignal show')\n      window.Telegram.WebApp.MainButton.show();\n    } else {\n      console.log('MainButtonSignal hide');\n      window.Telegram.WebApp.MainButton.hide();\n    }\n  })\n\n  createEffect(function updateText() {\n    if (text()) {\n      window.Telegram.WebApp.MainButton.setText(text());\n    } else {\n      window.Telegram.WebApp.MainButton.setText(originalText);\n    }\n  });\n\n  createEffect(function updateOnClick() {\n    if (props.onClick) {\n      window.Telegram.WebApp.MainButton.onClick(() => {\n        if (props.hapticForce && hapticSignal) {\n          hapticSignal();\n        }\n        props.onClick();\n      });\n    } else {\n      window.Telegram.WebApp.MainButton.onClick(undefined);\n    }\n  });\n\n  return {\n    visible,\n    setVisible,\n    text,\n    setText,\n  }\n}\n","import { createEffect, onCleanup, onMount } from 'solid-js'\nimport { createHapticImpactSignal } from '../signals/haptic'\nimport { createMainButtonSignal } from '../signals/main-button'\n\nexport type MainButtonProps = {\n  onClick?: () => void\n  text?: string\n  hapticForce?: Parameters<typeof createHapticImpactSignal>[0]\n}\n\nexport function MainButton(props: MainButtonProps) {\n  const mainButton = createMainButtonSignal({\n    onClick: props.onClick,\n    text: props.text,\n    hapticForce: props.hapticForce,\n    show: true,\n  })\n\n  onMount(() => {\n    console.log('MainButtonComponent mounted')\n    mainButton.setVisible(true)\n  })\n\n  onCleanup(() => {\n    console.log('MainButtonComponent unmounted')\n    mainButton.setVisible(false)\n  })\n\n  return null\n}\n","import { createMemo, createRoot, createRenderEffect, sharedConfig, enableHydration, createSignal, onCleanup, splitProps, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst PropAliases = {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n};\nconst DelegatedEvents = new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = new Set([\"html\", \"base\", \"head\", \"link\", \"meta\", \"style\", \"title\", \"body\", \"address\", \"article\", \"aside\", \"footer\", \"header\", \"main\", \"nav\", \"section\", \"body\", \"blockquote\", \"dd\", \"div\", \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\", \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"area\", \"audio\", \"img\", \"map\", \"track\", \"video\", \"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"portal\", \"source\", \"svg\", \"math\", \"canvas\", \"noscript\", \"script\", \"del\", \"ins\", \"caption\", \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"button\", \"datalist\", \"fieldset\", \"form\", \"input\", \"label\", \"legend\", \"meter\", \"optgroup\", \"option\", \"output\", \"progress\", \"select\", \"textarea\", \"details\", \"dialog\", \"menu\", \"summary\", \"details\", \"slot\", \"template\", \"acronym\", \"applet\", \"basefont\", \"bgsound\", \"big\", \"blink\", \"center\", \"content\", \"dir\", \"font\", \"frame\", \"frameset\", \"hgroup\", \"image\", \"keygen\", \"marquee\", \"menuitem\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"rb\", \"rtc\", \"shadow\", \"spacer\", \"strike\", \"tt\", \"xmp\", \"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"portal\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\", \"input\"]);\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    node.addEventListener(name, e => handler[0](handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  const prevString = typeof prev === \"string\";\n  if (value == null && prevString || typeof value === \"string\") return nodeStyle.cssText = value;\n  prevString && (nodeStyle.cssText = undefined, prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) {\n      value(node);\n    }\n  } else if (prop.slice(0, 3) === \"on:\") {\n    node.addEventListener(prop.slice(3), value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    node.addEventListener(prop.slice(10), value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    addEventListener(node, name, value, delegate);\n    delegate && delegateEvents([name]);\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (prop === \"class\" || prop === \"className\") className(node, value);else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach(elem => elem.remove());\n  }\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler(data, e) : handler(e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  props || (props = {});\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  props.ref && props.ref(node);\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    if (normalizeIncomingArray(array, value, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (Array.isArray(current)) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        t;\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item) || dynamic;\n    } else if ((t = typeof item) === \"string\") {\n      normalized.push(document.createTextNode(item));\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else normalized.push(document.createTextNode(item.toString()));\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction Assets() {\n  return;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction resolveSSRNode(node) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrSpread(accessor) {}\nfunction ssrBoolean(key, value) {}\nfunction ssrHydrationKey() {}\nfunction escape(html) {}\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  return createMemo(() => {\n    const component = p.component;\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, className, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, memo, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrBoolean, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };\n","import { JSX } from 'solid-js'\n\nexport type StableContainerProps = JSX.HTMLAttributes<HTMLElement> & {\n  children: JSX.Element\n}\n\nexport function StableContainer(props: StableContainerProps) {\n  return (\n    <main\n      style={{\n        height: 'var(--tg-viewport-stable-height)',\n        width: '100vw',\n        overflow: 'hidden',\n        backgroundColor: 'var(--tg-theme-bg-color)',\n        color: 'var(--tg-theme-text-color)',\n      }}\n      {...props}\n    >\n      {props.children}\n    </main>\n  )\n}\n","import { mergeProps } from \"solid-js\";\nimport { JSX } from \"solid-js/jsx-runtime\";\nimport { createHapticImpactSignal } from \"../signals/haptic\";\n\nexport type HapticButtonProps = JSX.ButtonHTMLAttributes<HTMLButtonElement> & {\n  children: JSX.Element;\n  hapticForce?: Parameters<typeof createHapticImpactSignal>[0];\n};\n\nexport function HapticButton(props: HapticButtonProps) {\n  const hapticSignal = createHapticImpactSignal(props.hapticForce ?? \"medium\");\n  const merged = mergeProps(props, {\n    onClick: (e) => {\n      hapticSignal();\n      if (props.onClick && typeof props.onClick == \"function\") {\n        props.onClick(e);\n      }\n    },\n  });\n\n  return <button {...merged}>{props.children}</button>;\n}\n","import { mergeProps } from \"solid-js\";\nimport { JSX } from \"solid-js/jsx-runtime\";\nimport { createHapticSelectionSignal } from \"../signals/haptic\";\n\nexport type HapticInputProps = JSX.InputHTMLAttributes<HTMLInputElement> & {\n  children?: JSX.Element;\n};\n\nexport function HapticInput(props: HapticInputProps) {\n  const hapticSelectionSignal = createHapticSelectionSignal();\n  const merged = mergeProps(props, {\n    onselectionchange: (e) => {\n      hapticSelectionSignal();\n    },\n  });\n\n  return <input {...merged}>{props.children}</input>;\n}\n","import { Accessor, createSignal, onCleanup } from \"solid-js\";\n\nconst [expanded, setExpanded] = createSignal(window.Telegram.WebApp.isExpanded);\n\nfunction updateViewport(isStable: boolean) {\n  if (isStable) {\n    setExpanded(window.Telegram.WebApp.isExpanded);\n  }\n}\n\nwindow.Telegram.WebApp.onEvent(\"viewportChanged\", updateViewport);\n\nexport function createExpandSignal(): [\n  expanded: Accessor<boolean>,\n  expand: () => void\n] {\n  const expand = () => window.Telegram.WebApp.expand();\n  return [expanded, expand];\n}\n","export function createCloseSignal() {\n  return window.Telegram.WebApp.close;\n}\n","import { WebAppInitData } from \"../types/telegram-webapp\";\n\nexport function createDataSignal(): [initData: () => WebAppInitData, sendData: (data: string) => void] {\n  return [() => window.Telegram.WebApp.initDataUnsafe, window.Telegram.WebApp.sendData];\n}","import { createSignal, onCleanup } from \"solid-js\";\nimport { ThemeParams } from \"../types/telegram-webapp\";\n\nconst [theme, setTheme] = createSignal<{\n  themeParams: ThemeParams;\n  colorScheme: typeof window.Telegram.WebApp.colorScheme;\n}>({\n  themeParams: window.Telegram.WebApp.themeParams,\n  colorScheme: window.Telegram.WebApp.colorScheme,\n});\n\nexport function createThemeSignal() {\n  function updateTheme() {\n    setTheme({\n      themeParams: window.Telegram.WebApp.themeParams,\n      colorScheme: window.Telegram.WebApp.colorScheme,\n    });\n  }\n\n  window.Telegram.WebApp.onEvent(\"themeChanged\", updateTheme);\n\n  onCleanup(() => {\n    window.Telegram.WebApp.offEvent(\"themeChanged\", updateTheme);\n  });\n\n  return theme;\n}\n","export function createUserSignal() {\n  return () => window.Telegram.WebApp.initDataUnsafe.user;\n}\n","import { createSignal } from \"solid-js\";\n\nconst [viewportHeight, setViewportHeight] = createSignal(\n  window.Telegram.WebApp.viewportHeight\n);\nconst [viewportStableHeight, setViewportStableHeight] = createSignal(\n  window.Telegram.WebApp.viewportStableHeight\n);\n\nfunction updateViewport(isStable: boolean) {\n  if (isStable) {\n    setViewportStableHeight(window.Telegram.WebApp.viewportStableHeight);\n  }\n\n  setViewportHeight(window.Telegram.WebApp.viewportHeight);\n}\n\nwindow.Telegram.WebApp.onEvent(\"viewportChanged\", updateViewport);\n\nexport function createViewportHeightSignal() {\n  return viewportHeight;\n}\n\nexport function createViewportStableHeightSignal() {\n  return viewportStableHeight;\n}\n","import { onCleanup, onMount } from 'solid-js'\n\nexport function LibTest(props: any) {\n  onMount(() => {\n    console.log('LibTest mounted')\n  })\n\n  onCleanup(() => {\n    console.log('LibTest unmounted')\n  })\n\n  return <span>lib test</span>\n}\n"],"names":["props","backButton","createBackButtonSignal","onClick","hapticForce","show","onMount","setVisible","onCleanup","mainButton","createMainButtonSignal","text","console","log","_tmpl$","_$spread","children","hapticSignal","createHapticImpactSignal","merged","mergeProps","e","hapticSelectionSignal","createHapticSelectionSignal","onselectionchange","updateViewport"],"mappings":"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"}